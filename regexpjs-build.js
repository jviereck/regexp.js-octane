(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process','global'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/lib/jit.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var nodeToCharCode = require('./parser').nodeToCharCode;\n\nvar Range = require('./utils').Range;\nvar RangeList = require('./utils').RangeList;\n\nfunction collectCharRanges(parseTree) {\n    // TODO: Merge this function with the one in `exec.js`.\n    function buildClassEntryRange(entry) {\n        switch (entry.type) {\n            case 'character':\n            case 'escape':\n                var charCode = nodeToCharCode(entry);\n                return new Range(charCode, charCode + 1);\n\n            case 'characterClassRange':\n                var min = nodeToCharCode(entry.min);\n                var max = nodeToCharCode(entry.max);\n\n                if (max < min) {\n                    // TODO: Better error message.\n                    throw new Error('Character not in right order');\n                }\n                return new Range(min, max + 1);\n\n            case 'empty':\n                return null;\n\n            case 'escapeChar':\n            default:\n                throw new Error('Unkown classRange entry type: ' + entry.type);\n        }\n    }\n\n    function walk(node, ranges) {\n        switch (node.type) {\n            case 'disjunction':\n                node.alternatives.forEach(function(node) {\n                    walk(node, ranges);\n                });\n                break;\n\n            case 'alternative':\n                node.terms.forEach(function(node) {\n                    walk(node, ranges);\n                });\n                break;\n\n            case 'character':\n            case 'escape':\n                var charCode = nodeToCharCode(node);\n                ranges.push(new RangeList(false, [new Range(charCode, charCode + 1)]));\n                break;\n\n            case 'quantifier':\n                walk(node.child, ranges);\n                break;\n\n            case 'dot':\n                var rl = new RangeList(true /* negativeMatch */);\n                // '\\n\\r\\u2028\\u2029'\n                [10, 13, 8232, 8233].forEach(function(charCode) {\n                    rl.push(new Range(charCode, charCode + 1));\n                });\n                ranges.push(rl);\n                break;\n\n            case 'characterClass':\n                var rl = new RangeList(node.negative);\n                node.classRanges.forEach(function(classEntry) {\n                    var res = buildClassEntryRange(classEntry);\n                    if (res) {\n                        rl.push(res);\n                    }\n                });\n                rl.simplify();\n                ranges.push(rl);\n                break;\n\n            case 'assertion':\n            case 'empty':\n                break;\n\n            case 'group':\n                // Only surpport the `ignore` type of groups (?:) in JIT mode.\n                if (node.behavior === 'ignore') {\n                    walk(node.disjunction, ranges);\n                    break;\n                }\n\n                // PASS THROUGH\n\n            case 'escapeChar':\n                // TODO: Implement me :)\n\n            case 'ref':\n            default:\n                throw new Error('Unsupported node type: ' + node.type);\n        }\n    }\n\n    var ranges = [];\n    walk(parseTree, ranges);\n\n    return ranges;\n}\n\n/**\n * Takes two lists of ranges and computes a list of ranges, such that\n * - the ranges do not inner-intersect with each other\n * - every range in either of the range list can be written as the sum of\n *   ranges given result range list.\n *\n * Eg.:\n *\n * listA  =         |---|   |----|\n * listB  = |--| |------------|\n *\n * result = |--| |--|---|---|-|--|\n *\n **/\nfunction splitLists(listA, listB) {\n    if (listA.length == 0) {\n        return listB;\n    }\n\n    var listA = listA.slice();\n    var listB = listB.slice();\n\n    listBLoop:\n    for (var n = 0; n < listB.length; n++) {\n        var s = listB[n];\n        for (var i = listA.length - 1; i >= 0; i--) {\n            var p = listA[i];\n            var A = p.subtract(s);\n            var B = p.intersect(s);\n            var sub = s.subtract(p);\n\n            listA.splice.apply(listA, [i, 1].concat(A, B));\n\n            if (sub.length == 0) {\n                continue listBLoop;\n            } else if (sub.length == 2) {\n                listB.push(sub[1]);\n            }\n            s = sub[0];\n        }\n        listA.push(s);\n    }\n\n    return listA;\n}\n\nfunction calcAlphabet(ranges) {\n    if (ranges.length === 0) {\n        return ranges;\n    }\n\n    var alphabet = ranges[0].list;\n    for (var i = 1; i < ranges.length; i++) {\n        var rangeList = ranges[i].list;\n\n        alphabet = splitLists(alphabet, rangeList);\n    }\n    return new RangeList(false, alphabet);\n}\n\nfunction isJITAble(parseTree, ignoreCase) {\n    var assertionCounter = 0;\n\n    function walk(node) {\n        switch (node.type) {\n            case 'disjunction':\n                return node.alternatives.every(walk);\n\n            case 'alternative':\n                return node.terms.every(walk);\n\n            case 'quantifier':\n                if (!node.greedy) {\n                    return false;\n                }\n                return walk(node.child);\n\n            case 'character':\n            case 'escape':\n            case 'dot':\n            case 'empty':\n                return true;\n\n            case 'characterClass':\n                // TODO: Implement support for escapeChar in classRanges in\n                // `collectCharRanges()` function.\n                return node.classRanges.every(function(entry) {\n                    return entry.type !== 'escapeChar';\n                });\n\n            case 'group':\n                // Only surpport the `ignore` type of groups (?:) in JIT mode.\n                if (node.behavior !== 'ignore') {\n                    return false;\n                }\n\n                return walk(node.disjunction);\n\n            case 'escapeChar':\n                // TODO: Not simple to enable this, but needs to add\n                // functionality for this case to `collectCharRanges()`.\n                return false;\n\n            case 'assertion':\n                if (assertionCounter++ === 0) {\n                    return true;\n                }\n                return false;\n\n            case 'ref':\n                return false;\n\n            default:\n                throw new Error('Unsupported node type: ' + node.type);\n        }\n    }\n\n    if (parseTree.type !== 'alternative' ||\n        parseTree.terms[0].type !== 'assertion' ||\n        parseTree.terms[0].sub !== 'start')\n    {\n        // TODO: Support other regexps than the ones that start with a ^ as well.\n        return false;\n    }\n\n    if (ignoreCase === true) {\n        // TODO: Support `ignoreCase` flag.\n        return false;\n    }\n\n    return walk(parseTree);\n}\n\n// -----------------------------------------------------------------------------\n\nfunction objectValues(obj) {\n    var keys = Object.keys(obj).sort();\n    var res = [];\n\n    for (var i = 0; i < keys.length; i++) {\n        res.push(obj[keys[i]]);\n    }\n    return res;\n}\n\nfunction State(id) {\n    this.id = id;\n    this.name = this.id;\n    this.transitions = [];\n    this.epsilonClosure = null;\n}\n\nState.prototype.addTransition = function(rangeList, targetState) {\n    this.epsilonClosure = null;\n    this.transitions.push({\n        matches: rangeList,\n        target: targetState\n    });\n};\n\nState.prototype.getEpsilonClosure = function() {\n    if (this.epsilonClosure) {\n        return this.epsilonClosure;\n    }\n\n    var self = this;\n    var closure = {};\n\n    function walk(state) {\n        closure[state.id] = state;\n\n        state.transitions.forEach(function(trans) {\n            if (trans.matches.hasIntersectRange(EPSILON_CHAR) && trans.target !== self) {\n                walk(trans.target);\n            }\n        });\n    }\n    walk(this);\n    return this.epsilonClosure = objectValues(closure).sort(function(a, b) {\n        return a.id - b.id;\n    });\n}\n\nState.prototype.toString = function() {\n    return this.name + '\\n     ' + this.transitions.map(function(trans) {\n        return trans.matches.toString() + ' => ' + trans.target.name;\n    }).join('  \\n     ');\n}\n\n// The empty match :)\nvar EPSILON = new RangeList(false, [new Range(-2, -1)]);\nvar OTHERS = new RangeList(false, [new Range(-3, -2)]);\n\nvar EPSILON_CHAR = EPSILON.list[0];\nvar OTHERS_CHAR = OTHERS.list[0];\n\nEPSILON.toString = function() { return '[EPSILON]'; }\nOTHERS.toString = function() { return '[OTHERS]'; }\n\nfunction NFA(parseTree) {\n    this.initalState = new State(0);\n    this.finalState = new State(1);\n    this.states = [this.initalState, this.finalState];\n    this.parseTree = parseTree;\n    this.str = parseTree.bit;\n\n    var charRanges = collectCharRanges(parseTree);\n    var alphabet = calcAlphabet(charRanges);\n    this.alphabet = alphabet;\n\n    function walk(node, nfa, fromState, toState) {\n        var i;\n        switch(node.type) {\n            case 'disjunction':\n                node.alternatives.forEach(function(node) {\n                    walk(node, nfa, fromState, toState);\n                });\n                break;\n\n            case 'alternative':\n                var terms = node.terms;\n\n                var states = [fromState];\n                // Create one state less than counter of terms.\n                for (i = 1; i < terms.length; i++) {\n                    states.push(nfa.newState());\n                }\n                states.push(toState);\n\n                for (i = 0; i < terms.length; i++) {\n                    walk(terms[i], nfa, states[i], states[i + 1]);\n                }\n                break;\n\n            case 'character':\n            case 'escape':\n            case 'dot':\n            case 'characterClass':\n                var rangeList = collectCharRanges(node)[0];\n                var negative = !!node.negative;\n\n                // Calculate the characters/ranges of the alphabet, that are\n                // required to write all the possible ranges in rangeList.\n                // In the case of a negative list, reverse to get all the\n                // other that are not matched.\n                var matches = alphabet.intersect(rangeList, negative);\n\n                if (negative) {\n                    matches.push(OTHERS);\n                }\n\n                fromState.addTransition(matches, toState);\n                break;\n\n            case 'assertion':\n            case 'empty':\n                fromState.addTransition(EPSILON, toState);\n                break;\n\n            case 'group':\n                walk(node.disjunction, nfa, fromState, toState);\n                break;\n\n            default:\n                throw new Error('Need to implement ' + node.type + ' support in NFA builder');\n        }\n    }\n\n    console.log('alphabet:', alphabet.toString());\n\n    walk(parseTree, this, this.initalState, this.finalState);\n}\n\nNFA.prototype.newState = function() {\n    var state = new State(this.states.length);\n    this.states.push(state);\n    return state;\n}\n\nNFA.prototype.toString = function() {\n    return 'NFA dump\\n  ' + this.states.map(function(state) {\n        return state.toString();\n    }).join('  \\n  ');\n};\n\nfunction DFAState(id, nfaStates) {\n    State.call(this, id);\n    this.nfaStates = nfaStates;\n    this.final = false;\n    this.name = id + ': NFA-States={' + nfaStates.map(function(state) {return state.name}).join(', ') + '} ';\n}\n\nDFAState.prototype = new State(0);\n\nDFAState.prototype.codeGen = function(out) {\n    out.push('    case ' + this.id + ':');\n\n    this.transitions.forEach(function(trans) {\n        var matche = trans.matches;\n        var cond = '(' + matche.min + ' <= charCode && ' + (matche.max - 1) + ' >= charCode)';\n\n        out.push('      if(' + cond + ')');\n        out.push('      {');\n        out.push('        state=' + trans.target.id + '; continue outer_loop;')\n        out.push('      }');\n    });\n\n    if (this.final) {\n        out.push('      // MATCHED!');\n        out.push('      return [str.substring(0, idx + 1)];');\n    } else {\n        out.push('      break');\n    }\n}\n\n/**\n * moveNFA(A, a)\n *\n *   returns all states that can be reached from a state in A by doing the\n *   transition with the character `a`\n */\nfunction moveNFA(dfaState, character) {\n    var res = {};\n    dfaState.nfaStates.forEach(function(state) {\n        state.transitions.forEach(function(trans) {\n            if (trans.matches.hasIntersectRange(character)) {\n                var target = trans.target;\n                res[target.id] = target;\n            }\n        })\n    });\n    return objectValues(res);\n}\n\n/**\n *\n */\nfunction epsilonClosureFromStates(states) {\n    var res = {};\n    states.forEach(function(state) {\n        state.getEpsilonClosure().forEach(function(closureState) {\n            res[closureState.id] = closureState;\n        });\n    });\n    var id = Object.keys(res).map(function(a) {return parseInt(a, 10);}).sort().join(',');\n    var res = objectValues(res);\n    res.id = id;\n    return res;\n}\n\nfunction DFA(nfa) {\n    var nfaStates = nfa.states;\n    var alphabet = nfa.alphabet.clone();\n    alphabet.push(OTHERS_CHAR);\n    this.str = nfa.str;\n\n    // Actual NFA -> DFA algorith.\n    // Following the slides from\n    // http://web.cecs.pdx.edu/~harry/compilers/slides/LexicalPart3.pdf\n\n    var idCounter = 0;\n    var initialState = new DFAState(idCounter++, nfaStates[0].getEpsilonClosure());\n\n    // Use this map to identify if a set of states is already mapped to a\n    // DFAState.\n    var closureMap = {};\n    closureMap[initialState.nfaStates.id] = initialState;\n\n    var states = this.states = [initialState];\n\n    var unmarkedStates = [initialState];\n\n    var current;\n    while (current = unmarkedStates.shift()) {\n        alphabet.list.forEach(function(ch) {\n            var t = moveNFA(current, ch);\n\n            // No moves from current for this character -> nothing todo.\n            if (t.length === 0) {\n                return;\n            }\n\n            var S = epsilonClosureFromStates(t);\n\n            var targetState = closureMap[S.id];\n            if (!targetState) {\n                targetState = new DFAState(idCounter++, S);\n                closureMap[S.id] = targetState\n                unmarkedStates.push(targetState);\n                states.push(targetState);\n            }\n\n            current.addTransition(ch, targetState);\n        });\n    }\n\n    // Get all the final states.\n    // Do this by a nasty hack. Look at all closure ids that contain a `1` state\n    // which is by definition the final state.\n    var finalStates = Object.keys(closureMap).filter(function(name) {\n        return /\\b1\\b/.test(name);\n    }).map(function(id) {\n        return closureMap[id];\n    });\n    finalStates.forEach(function(dfaState) {\n        dfaState.final = true;\n    });\n\n    this.finalStates = finalStates;\n\n\n    console.log('NFA', nfa.toString());\n    console.log('all states', this.toString());\n\n    var names = finalStates.map(function(state) {\n        return state.name;\n    });\n\n    console.log('final states:', '\\n  ' + names.join('\\n  '));\n\n    console.log(this.codeGen().join('\\n'))\n\n}\n\nDFA.prototype.toString = function() {\n    return 'DFA dump\\n  ' + this.states.map(function(state) {\n        return state.toString();\n    }).join('  \\n  ');\n};\n\nDFA.prototype.codeGen = function() {\n    var out = [];\n    out.push('//----------------------------------------------------------------')\n    out.push('// Genereated by RegExp.JS');\n    out.push('//')\n    out.push('// Input=/' + this.str + '/');\n    out.push('//----------------------------------------------------------------')\n    out.push('var state = 0;');\n    out.push('var charCode = 0;');\n    out.push('var len=str.length;');\n    out.push('var idx=-1;');\n    out.push('');\n    out.push('outer_loop:')\n    out.push('while((++idx)<len) {');\n    out.push('  charCode = str.charCodeAt(idx);');\n    out.push('  switch(state) {');\n\n    this.states.forEach(function(state) {\n        state.codeGen(out);\n    });\n\n    out.push('  }');\n    out.push('  // Did not match.');\n    out.push('  return null;');\n    out.push('}');\n\n    return out;\n}\n\n\nexports.EPSILON = EPSILON;\nexports.State = State;\nexports.isJITAble = isJITAble;\nexports.collectCharRanges = collectCharRanges;\nexports.calcAlphabet = calcAlphabet;\n\nexports.NFA = NFA;\nexports.DFA = DFA;\n\n\n//@ sourceURL=/lib/jit.js"
));

require.define("/lib/parser.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// See: 15.10.1\n//\n// Pattern ::\n//      Disjunction\n//\n// Disjunction ::\n//      Alternative\n//      Alternative | Disjunction\n//\n// Alternative ::\n//      [empty]\n//      Alternative Term\n//\n// Term ::\n//      Assertion\n//      Atom\n//      Atom Quantifier\n//\n// Assertion ::\n//      ^\n//      $\n//      \\ b\n//      \\ B\n//      ( ? = Disjunction )\n//      ( ? ! Disjunction )\n//\n// Quantifier ::\n//      QuantifierPrefix\n//      QuantifierPrefix ?\n//\n// QuantifierPrefix ::\n//      *\n//      +\n//      ?\n//      { DecimalDigits }\n//      { DecimalDigits , }\n//      { DecimalDigits , DecimalDigits }\n//\n// Atom ::\n//      PatternCharacter\n//      .\n//      \\ AtomEscape\n//      CharacterClass\n//      ( Disjunction )\n//      ( ? : Disjunction )\n//\n// PatternCharacter ::\n//      SourceCharacter but not any of: ^ $ \\ . * + ? ( ) [ ] { } |\n//\n// AtomEscape ::\n//      DecimalEscape\n//      CharacterEscape\n//      CharacterClassEscape\n//\n// CharacterEscape ::\n//      ControlEscape\n//      c ControlLetter\n//      HexEscapeSequence\n//      UnicodeEscapeSequence\n//      IdentityEscape\n//\n// ControlEscape ::\n//      one of f n r t v\n// ControlLetter ::\n//      one of\n//          a b c d e f g h i j k l m n o p q r s t u v w x y z\n//          A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n//\n// IdentityEscape ::\n//      SourceCharacter but not IdentifierPart\n//      <ZWJ>\n//      <ZWNJ>\n//\n// DecimalEscape ::\n//      DecimalIntegerLiteral [lookahead ∉ DecimalDigit]\n//      CharacterClassEscape :: one of\n//      d D s S w W\n//\n// CharacterClass ::\n//      [ [lookahead ∉ {^}] ClassRanges ]\n//      [ ^ ClassRanges ]\n//\n// ClassRanges ::\n//      [empty]\n//      NonemptyClassRanges\n//\n// NonemptyClassRanges ::\n//      ClassAtom\n//      ClassAtom NonemptyClassRangesNoDash\n//      ClassAtom - ClassAtom ClassRanges\n//\n// NonemptyClassRangesNoDash ::\n//      ClassAtom\n//      ClassAtomNoDash NonemptyClassRangesNoDash\n//      ClassAtomNoDash - ClassAtom ClassRanges\n//\n// ClassAtom ::\n//      -\n//      ClassAtomNoDash\n//\n// ClassAtomNoDash ::\n//      SourceCharacter but not one of \\ or ] or -\n//      \\ ClassEscape\n//\n// ClassEscape ::\n//      DecimalEscape\n//      b\n//      CharacterEscape\n//      CharacterClassEscape\n\nfunction parse(str) {\n    var pos = 0;\n    var lastMatchIdx = 0;\n    var lastMatchClosed = 0;\n\n    function addRaw(node) {\n        node.raw = str.substring(node.from, node.to);\n        return node;\n    }\n\n    function createAssertion(sub) {\n        return addRaw({\n            type: 'assertion',\n            sub:  sub,\n            from: pos - 1,\n            to: pos\n        });\n    }\n\n    function createCharacter(matches) {\n        return addRaw({\n            type: 'character',\n            char: matches[0],\n            from: pos - 1,\n            to: pos\n        });\n    }\n\n    function createDisjunction(alternatives, from, to) {\n        return addRaw({\n            type: 'disjunction',\n            alternatives: alternatives,\n            from: from,\n            to: to\n        });\n    }\n\n    function createEmpty() {\n        return addRaw({\n            type: 'empty',\n            from: pos,\n            to: pos\n        });\n    }\n\n    function createDot(name) {\n        return addRaw({\n            type: 'dot',\n            from: pos - 1,\n            to: pos\n        });\n    }\n\n    function createEscaped(name, value, fromOffset) {\n        fromOffset = fromOffset || 0;\n        return addRaw({\n            type: 'escape',\n            name: name,\n            value: value,\n            from: pos - (value.length + fromOffset),\n            to: pos\n        });\n    }\n\n    function createEscapedChar(value) {\n        return addRaw({\n            type: 'escapeChar',\n            value: value,\n            from: pos - 2,\n            to: pos\n        });\n    }\n\n    function createRef(ref) {\n        return addRaw({\n            type: 'ref',\n            ref: parseInt(ref, 10),\n            from: pos - 1 - ref.length,\n            to: pos\n        });\n    }\n\n    function createGroup(behavior, disjunction, from, to) {\n        return addRaw({\n            type: 'group',\n            behavior: behavior,\n            disjunction: disjunction,\n            from: from,\n            to: to\n        });\n    }\n\n    function createQuantifier(min, max, from, to) {\n        if (to == null) {\n            from = pos - 1;\n            to = pos;\n        }\n\n        return addRaw({\n            type: 'quantifier',\n            min: min,\n            max: max,\n            greedy: true,\n            child: null, // set later on,\n            from: from,\n            to: to\n        });\n    }\n\n    function createAlternative(terms, from, to) {\n        return addRaw({\n            type: 'alternative',\n            terms: terms,\n            from: from,\n            to: to\n        });\n    }\n\n    function createCharacterClass(classRanges, negative, from, to) {\n        return addRaw({\n            type: 'characterClass',\n            classRanges: classRanges,\n            negative: negative,\n            from: from,\n            to: to\n        });\n    }\n\n    function createClassRange(min, max, from, to) {\n        var charCodeMin = nodeToCharCode(min);\n        var charCodeMax = nodeToCharCode(max);\n\n        // See 15.10.2.15:\n        if (charCodeMin > charCodeMax) {\n            throw syntaxError('invalid range in character class');\n        }\n\n        return addRaw({\n            type: 'characterClassRange',\n            min: min,\n            max: max,\n            from: from,\n            to: to\n        });\n    }\n\n    function isEmpty(obj) {\n        return obj.type === 'empty';\n    }\n\n    function incr(amount) {\n        amount = (amount || 1);\n        var res = str.substring(pos, pos + amount);\n        pos += (amount || 1);\n        return res;\n    }\n\n    function skip(value) {\n        if (!match(value)) {\n            throw syntaxError('character: ' + value);\n        }\n    }\n\n    function match(value) {\n        if (str.indexOf(value, pos) === pos) {\n            return incr(value.length);\n        }\n    }\n\n    function lookahead() {\n        return str[pos];\n    }\n\n    function current(value) {\n        return str.indexOf(value, pos) === pos;\n    }\n\n    function next(value) {\n        return str[pos + 1] === value;\n    }\n\n    function matchReg(regExp) {\n        var subStr = str.substring(pos);\n        var res = subStr.match(regExp);\n        if (res) {\n            res.from = pos;\n            incr(res[0].length);\n            res.to = pos;\n        }\n        return res;\n    }\n\n    function parseDisjunction() {\n        // Disjunction ::\n        //      Alternative\n        //      Alternative | Disjunction\n        var res = [], from = pos;\n        res.push(parseAlternative());\n\n        while (match('|')) {\n            res.push(parseAlternative());\n        }\n\n        if (res.length === 1) {\n            return res[0];\n        }\n\n        return createDisjunction(res, from, pos);\n    }\n\n    function parseAlternative() {\n        var res = [], from = pos;\n\n        // Alternative ::\n        //      [empty]\n        //      Alternative Term\n        while (term = parseTerm()) {\n            if (isEmpty(term)) {\n                // Only add Empty if there is nothing else in the result array.\n                // Otherwise ignore it to save noice in the AST.\n                if (res.length === 0) {\n                    res.push(term);\n                }\n                break;\n            }\n\n            res.push(term);\n        }\n\n        return createAlternative(res, from, pos);\n    }\n\n    function parseTerm() {\n        // Term ::\n        //      Assertion\n        //      Atom\n        //      Atom Quantifier\n\n        if (pos >= str.length || current('|') || current(')')) {\n            return createEmpty();\n        }\n\n        var assertion = parseAssertion();\n\n        if (assertion) {\n            return assertion;\n        }\n\n        var matchIdx = lastMatchIdx;\n\n        var atom = parseAtom();\n        if (!atom) {\n            throw syntaxError('Expected atom')\n            // return createEmpty();\n        }\n        var quantifier = parseQuantifier() || false;\n        if (quantifier) {\n            quantifier.child = atom;\n            if (matchIdx + 1 <= lastMatchIdx) {\n                quantifier.firstMatchIdx = matchIdx + 1;\n                quantifier.lastMatchIdx = lastMatchIdx;\n            }\n\n            return quantifier;\n        }\n        return atom;\n    }\n\n    function parseGroup(matchA, typeA, matchB, typeB) {\n        var type = null, from = pos;\n\n        if (match(matchA)) {\n            type = typeA;\n        } else if (match(matchB)) {\n            type = typeB;\n        } else {\n            return false;\n        }\n\n        var matchIdx;\n        if (type === 'normal') {\n            matchIdx = ++lastMatchIdx;\n        } else {\n            matchIdx = lastMatchIdx;\n        }\n\n        res = parseDisjunction();\n        if (!res) {\n            throw syntaxError('disjunction');\n        }\n        skip(')');\n        var group = createGroup(type, res, from, pos);\n\n        if (type == 'normal') {\n            group.matchIdx = matchIdx;\n            group.lastMatchIdx = lastMatchIdx;\n            lastMatchClosed++;\n        } else if (type == 'lookahead' || type == 'negativeLookahead') {\n            if (matchIdx !== lastMatchIdx) {\n                group.firstMatchIdx = matchIdx + 1;\n                group.lastMatchIdx = lastMatchIdx;\n            }\n        }\n        return group;\n    }\n\n    function parseAssertion() {\n        // Assertion ::\n        //      ^\n        //      $\n        //      \\ b\n        //      \\ B\n        //      ( ? = Disjunction )\n        //      ( ? ! Disjunction )\n        var res, from = pos;\n\n        if (match('^')) {\n            return createAssertion('start');\n        } else if (match('$')) {\n            return createAssertion('end');\n        } else if (res = matchReg(/^\\\\(b|B)/)) {\n            return createEscapedChar(res[1]);\n        } else {\n            return parseGroup('(?=', 'lookahead', '(?!', 'negativeLookahead');\n        }\n    }\n\n    function parseQuantifier() {\n        // Quantifier ::\n        //      QuantifierPrefix\n        //      QuantifierPrefix ?\n        //\n        // QuantifierPrefix ::\n        //      *\n        //      +\n        //      ?\n        //      { DecimalDigits }\n        //      { DecimalDigits , }\n        //      { DecimalDigits , DecimalDigits }\n\n        var res;\n        var quantifier;\n        var min, max;\n\n        if (match('*')) {\n            quantifier = createQuantifier(0);\n        }\n        else if (match('+')) {\n            quantifier = createQuantifier(1);\n        }\n        else if (match('?')) {\n            quantifier = createQuantifier(0, 1);\n        }\n        else if (res = matchReg(/^\\{([0-9]+)\\}/)) {\n            min = parseInt(res[1], 10);\n            quantifier = createQuantifier(min, min, res.from, res.to);\n        }\n        else if (res = matchReg(/^\\{([0-9]+),\\}/)) {\n            min = parseInt(res[1], 10);\n            quantifier = createQuantifier(min, undefined, res.from, res.to);\n        }\n        else if (res = matchReg(/^\\{([0-9]+),([0-9]+)\\}/)) {\n            min = parseInt(res[1], 10);\n            max = parseInt(res[2], 10);\n            if (min > max) {\n                throw syntaxError('numbers out of order in {} quantifier');\n            }\n            quantifier = createQuantifier(min, max, res.from, res.to);\n        }\n\n        if (quantifier) {\n            if (match('?')) {\n                quantifier.greedy = false;\n                quantifier.to += 1;\n            }\n        }\n\n        return quantifier;\n    }\n\n    function parseAtom() {\n        // Atom ::\n        //      PatternCharacter\n        //      .\n        //      \\ AtomEscape\n        //      CharacterClass\n        //      ( Disjunction )\n        //      ( ? : Disjunction )\n\n        var res;\n\n        // jviereck: allow ']', '}' here as well to be compatible with browser's\n        //   implementations: ']'.match(/]/);\n        // if (res = matchReg(/^[^^$\\\\.*+?()[\\]{}|]/)) {\n        if (res = matchReg(/^[^^$\\\\.*+?(){[|]/)) {\n            //      PatternCharacter\n            return createCharacter(res);\n        }\n        else if (match('.')) {\n            //      .\n            return createDot();\n        }\n        else if (match('\\\\')) {\n            //      \\ AtomEscape\n            var res = parseAtomEscape();\n            if (!res) {\n                throw syntaxError('atomEscape');\n            }\n            return res;\n        }\n        else if (res = parseCharacterClass()) {\n            return res;\n        }\n        else {\n            //      ( Disjunction )\n            //      ( ? : Disjunction )\n            return parseGroup('(?:', 'ignore', '(', 'normal');\n        }\n    }\n\n    function parseClassEscape() {\n        return parseAtomEscape(true);\n    }\n\n    function parseAtomEscape(insideCharacterClass) {\n        // AtomEscape ::\n        //      DecimalEscape\n        //      CharacterEscape\n        //      CharacterClassEscape\n\n        var res;\n\n        res = parseDecimalEscape();\n        if (res) {\n            return res;\n        }\n\n        // For ClassEscape\n        if (insideCharacterClass) {\n            if (match('b')) {\n                // 15.10.2.19\n                // The production ClassEscape :: b evaluates by returning the\n                // CharSet containing the one character <BS> (Unicode value 0008).\n                return createEscaped('unicode', '0008', -2);\n            } else if (match('B')) {\n                throw syntaxError('\\\\B not possible inside of CharacterClass');\n            }\n        }\n\n        res = parseCharacterEscape();\n        if (res) {\n            return res;\n        }\n\n        res = parseCharacterClassEscape();\n        if (res) {\n            return res;\n        }\n\n        return res;\n    }\n\n\n    function parseDecimalEscape() {\n        // DecimalEscape ::\n        //      DecimalIntegerLiteral [lookahead ∉ DecimalDigit]\n        //      CharacterClassEscape :: one of\n        //      d D s S w W\n\n        var res, match;\n\n        if (res = matchReg(/^(?!0)\\d+/)) {\n            match = res[0];\n            var refIdx = parseInt(res[0], 10);\n            if (refIdx <= lastMatchClosed) {\n                // If the number is smaller than the matching-groups found so\n                // far, then it is a reference...\n                return createRef(res[0]);\n            } else {\n                // ... otherwise it needs to be interpreted as a octal (if the\n                // number is in an octal format). If it is NOT octal format,\n                // then the slash is ignored and the number is matched later\n                // as normal characters.\n\n                // Reset the position again, as maybe only parts of the previous\n                // matched numbers are actual octal numbers. E.g. in '019' only\n                // the '01' should be matched.\n                incr(-res[0].length);\n                if (res = matchReg(/^[0-7]{1,3}/)) {\n                    return createEscaped('octal', res[0], 1);\n                } else {\n                    // If we end up here, we have a case like /\\91/. Then the\n                    // first slash is to be ignored and the 9 & 1 to be treated\n                    // like ordinary characters. Create a character for the\n                    // first number only here - other number-characters\n                    // (if available) will be matched later.\n                    res = matchReg(/^[89]/);\n                    return createCharacter(res);\n                }\n            }\n        }\n        // Only allow octal numbers in the following. All matched numbers start\n        // with a zero (if the do not, the previous if-branch is executed).\n        // If the number is not octal format and starts with zero (e.g. `091`)\n        // then only the zeros `0` is treated here and the `91` are ordinary\n        // characters.\n        // Example:\n        //   /\\091/.exec('\\091')[0].length === 3\n        else if (res = matchReg(/^[0-7]{1,3}/)) {\n            match = res[0];\n            if (/^0{1,3}$/.test(match)) {\n                // If they are all zeros, then only take the first one.\n                return createEscaped('null', '', match.length + 1);\n            } else {\n                return createEscaped('octal', match, 1);\n            }\n        } else if (res = matchReg(/^[dDsSwW]/)) {\n            return createEscapedChar(res[0]);\n        }\n         return false;\n    }\n\n    function parseCharacterEscape() {\n        // CharacterEscape ::\n        //      ControlEscape\n        //      c ControlLetter\n        //      HexEscapeSequence\n        //      UnicodeEscapeSequence\n        //      IdentityEscape\n\n        var res;\n        if (res = matchReg(/^[fnrtv]/)) {\n        //      ControlEscape\n            return createEscapedChar(res[0]);\n        } else if (res = matchReg(/^c([a-zA-Z])/)) {\n        //      c ControlLetter\n            return createEscaped('controlLetter', res[1], 1);\n        } else if (res = matchReg(/^x([0-9a-fA-F]{2})/)) {\n        //      HexEscapeSequence\n            return createEscaped('hex', res[1], 1);\n        } else  if (res = matchReg(/^u([0-9a-fA-F]{4})/)) {\n        //      UnicodeEscapeSequence\n            return createEscaped('unicode', res[1], 1);\n        } else {\n        //      IdentityEscape\n            return parseIdentityEscape();\n        }\n    }\n\n    // Taken from the esprima parser.\n    function isIdentifierPart(ch) {\n        var NonAsciiIdentifierPart = new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0300-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u0483-\\u0487\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0610-\\u061a\\u0620-\\u0669\\u066e-\\u06d3\\u06d5-\\u06dc\\u06df-\\u06e8\\u06ea-\\u06fc\\u06ff\\u0710-\\u074a\\u074d-\\u07b1\\u07c0-\\u07f5\\u07fa\\u0800-\\u082d\\u0840-\\u085b\\u08a0\\u08a2-\\u08ac\\u08e4-\\u08fe\\u0900-\\u0963\\u0966-\\u096f\\u0971-\\u0977\\u0979-\\u097f\\u0981-\\u0983\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bc-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09ce\\u09d7\\u09dc\\u09dd\\u09df-\\u09e3\\u09e6-\\u09f1\\u0a01-\\u0a03\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a59-\\u0a5c\\u0a5e\\u0a66-\\u0a75\\u0a81-\\u0a83\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abc-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ad0\\u0ae0-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3c-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5c\\u0b5d\\u0b5f-\\u0b63\\u0b66-\\u0b6f\\u0b71\\u0b82\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd0\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c58\\u0c59\\u0c60-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbc-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0cde\\u0ce0-\\u0ce3\\u0ce6-\\u0cef\\u0cf1\\u0cf2\\u0d02\\u0d03\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4e\\u0d57\\u0d60-\\u0d63\\u0d66-\\u0d6f\\u0d7a-\\u0d7f\\u0d82\\u0d83\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e01-\\u0e3a\\u0e40-\\u0e4e\\u0e50-\\u0e59\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb9\\u0ebb-\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0edc-\\u0edf\\u0f00\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e-\\u0f47\\u0f49-\\u0f6c\\u0f71-\\u0f84\\u0f86-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1049\\u1050-\\u109d\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u135d-\\u135f\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176c\\u176e-\\u1770\\u1772\\u1773\\u1780-\\u17d3\\u17d7\\u17dc\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a1b\\u1a20-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1aa7\\u1b00-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1bf3\\u1c00-\\u1c37\\u1c40-\\u1c49\\u1c4d-\\u1c7d\\u1cd0-\\u1cd2\\u1cd4-\\u1cf6\\u1d00-\\u1de6\\u1dfc-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u200c\\u200d\\u203f\\u2040\\u2054\\u2071\\u207f\\u2090-\\u209c\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d7f-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2de0-\\u2dff\\u2e2f\\u3005-\\u3007\\u3021-\\u302f\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u3099\\u309a\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua62b\\ua640-\\ua66f\\ua674-\\ua67d\\ua67f-\\ua697\\ua69f-\\ua6f1\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua827\\ua840-\\ua873\\ua880-\\ua8c4\\ua8d0-\\ua8d9\\ua8e0-\\ua8f7\\ua8fb\\ua900-\\ua92d\\ua930-\\ua953\\ua960-\\ua97c\\ua980-\\ua9c0\\ua9cf-\\ua9d9\\uaa00-\\uaa36\\uaa40-\\uaa4d\\uaa50-\\uaa59\\uaa60-\\uaa76\\uaa7a\\uaa7b\\uaa80-\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaef\\uaaf2-\\uaaf6\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff10-\\uff19\\uff21-\\uff3a\\uff3f\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]')\n\n        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)\n            (ch >= 65 && ch <= 90) ||         // A..Z\n            (ch >= 97 && ch <= 122) ||        // a..z\n            (ch >= 48 && ch <= 57) ||         // 0..9\n            (ch === 92) ||                    // \\ (backslash)\n            ((ch >= 0x80) && NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n    }\n\n    function parseIdentityEscape() {\n        // IdentityEscape ::\n        //      SourceCharacter but not IdentifierPart\n        //      <ZWJ>\n        //      <ZWNJ>\n\n        var ZWJ = '\\u200C';\n        var ZWNJ = '\\u200D';\n\n        var res;\n\n        if (!isIdentifierPart(lookahead())) {\n            return createEscaped('identifier', incr());\n        }\n\n        if (match(ZWJ)) {\n        //      <ZWJ>\n            return createEscaped('identifier', ZWJ);\n        } else if (match(ZWNJ)) {\n        //      <ZWNJ>\n            return createEscaped('identifier', ZWNJ);\n        }\n\n        return null;\n    }\n\n    function parseCharacterClass() {\n        // CharacterClass ::\n        //      [ [lookahead ∉ {^}] ClassRanges ]\n        //      [ ^ ClassRanges ]\n\n        var res, from = pos;\n        if (res = matchReg(/^\\[\\^/)) {\n            res = parseClassRanges();\n            skip(']');\n            return createCharacterClass(res, true, from, pos);\n        } else if (match('[')) {\n            res = parseClassRanges();\n            skip(']');\n            return createCharacterClass(res, false, from, pos);\n        }\n\n        return null;\n    }\n\n    function parseClassRanges() {\n        // ClassRanges ::\n        //      [empty]\n        //      NonemptyClassRanges\n\n        var res;\n        if (current(']')) {\n            // Empty array means nothing insinde of the ClassRange.\n            return [];\n        } else {\n            res = parseNonemptyClassRanges();\n            if (!res) {\n                throw syntaxError('nonEmptyClassRanges');\n            }\n            return res;\n        }\n    }\n\n    function parseHelperClassRanges(atom) {\n        var from = pos, to, res;\n        if (current('-') && !next(']')) {\n        //      ClassAtom - ClassAtom ClassRanges\n            skip('-');\n\n            res = parseClassAtom();\n            if (!res) {\n                throw syntaxError('classAtom');\n            }\n            to = pos;\n            var classRanges = parseClassRanges();\n            if (!classRanges) {\n                throw syntaxError('classRanges');\n            }\n            if (classRanges.type === 'empty') {\n                return [createClassRange(atom, res, from, to)];\n            }\n            return [createClassRange(atom, res, from, to)].concat(classRanges);\n        }\n\n        res = parseNonemptyClassRangesNoDash();\n        if (!res) {\n            throw syntaxError('nonEmptyClassRangesNoDash');\n        }\n\n        return [atom].concat(res);\n    }\n\n    function parseNonemptyClassRanges() {\n        // NonemptyClassRanges ::\n        //      ClassAtom\n        //      ClassAtom NonemptyClassRangesNoDash\n        //      ClassAtom - ClassAtom ClassRanges\n\n        var atom = parseClassAtom();\n        if (!atom) {\n            throw syntaxError('classAtom');\n        }\n\n        if (current(']')) {\n        //      ClassAtom\n            return [atom];\n        }\n\n        //      ClassAtom NonemptyClassRangesNoDash\n        //      ClassAtom - ClassAtom ClassRanges\n        return parseHelperClassRanges(atom);\n    }\n\n    function parseNonemptyClassRangesNoDash() {\n        // NonemptyClassRangesNoDash ::\n        //      ClassAtom\n        //      ClassAtomNoDash NonemptyClassRangesNoDash\n        //      ClassAtomNoDash - ClassAtom ClassRanges\n\n        var res = parseClassAtom();\n        if (!res) {\n            throw syntaxError('classAtom');\n        }\n        if (current(']')) {\n            //      ClassAtom\n            return res;\n        }\n\n        //      ClassAtomNoDash NonemptyClassRangesNoDash\n        //      ClassAtomNoDash - ClassAtom ClassRanges\n        return parseHelperClassRanges(res);\n    }\n\n    function parseClassAtom() {\n        // ClassAtom ::\n        //      -\n        //      ClassAtomNoDash\n        if (match('-')) {\n            return createCharacter('-');\n        } else {\n            return parseClassAtomNoDash();\n        }\n    }\n\n    function parseClassAtomNoDash() {\n        // ClassAtomNoDash ::\n        //      SourceCharacter but not one of \\ or ] or -\n        //      \\ ClassEscape\n\n        var res;\n        if (res = matchReg(/^[^\\\\\\]-]/)) {\n            return createCharacter(res[0]);\n        } else if (match('\\\\')) {\n            res = parseClassEscape();\n            if (!res) {\n                throw syntaxError('classEscape');\n            }\n            return res;\n        }\n    }\n\n    function syntaxError(str) {\n        return new SyntaxError(str);\n    }\n\n    try {\n        var result = parseDisjunction();\n        result.lastMatchIdx = lastMatchIdx;\n    } catch(e) {\n        return {\n            error: e\n        };\n    }\n\n    if (result.to !== str.length) {\n        throw syntaxError('Could not parse entire input - got stuck.');\n    }\n\n    return result;\n};\n\nfunction nodeToCharCode(node) {\n    switch (node.type) {\n        case 'character':\n            return node.char.charCodeAt(0);\n\n        case 'escape':\n            switch (node.name) {\n                case 'unicode':\n                    return parseInt(node.value, 16);\n                case 'controlLetter':\n                    return node.value.charCodeAt(0) % 32;\n                case 'identifier':\n                    return node.value.charCodeAt(0);\n                case 'octal':\n                    return parseInt(node.value, 8);\n                case 'hex':\n                    return parseInt(node.value, 16);\n                case 'null':\n                    return 0;\n                default:\n                    throw new Error('Unsupported node escape name: ' + node.name);\n            }\n\n        default:\n            throw new Error('Unkown nodeType: ' + node.type);\n    }\n\n    return null;\n}\n\nexports.nodeToCharCode = nodeToCharCode;\nexports.parse = parse;\n\n//@ sourceURL=/lib/parser.js"
));

require.define("/lib/utils.js",Function(['require','module','exports','__dirname','__filename','process','global'],"function clone(src) {\n  function mixin(dest, source, copyFunc) {\n    var name, s, i, empty = {};\n    for(name in source){\n      // the (!(name in empty) || empty[name] !== s) condition avoids copying properties in \"source\"\n      // inherited from Object.prototype.   For example, if dest has a custom toString() method,\n      // don't overwrite it with the toString() method that source inherited from Object.prototype\n      s = source[name];\n      if(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){\n        dest[name] = copyFunc ? copyFunc(s) : s;\n      }\n    }\n    return dest;\n  }\n\n  if(!src || typeof src != \"object\" || Object.prototype.toString.call(src) === \"[object Function]\"){\n    // null, undefined, any non-object, or function\n    return src;  // anything\n  }\n  if(src.nodeType && \"cloneNode\" in src){\n    // DOM Node\n    return src.cloneNode(true); // Node\n  }\n  if(src instanceof Date){\n    // Date\n    return new Date(src.getTime());  // Date\n  }\n  if(src instanceof RegExp){\n    // RegExp\n    return new RegExp(src);   // RegExp\n  }\n  var r, i, l;\n  if(src instanceof Array){\n    // array\n    r = [];\n    for(i = 0, l = src.length; i < l; ++i){\n      if(i in src){\n        r.push(clone(src[i]));\n      }\n    }\n    // we don't clone functions for performance reasons\n    //    }else if(d.isFunction(src)){\n    //      // function\n    //      r = function(){ return src.apply(this, arguments); };\n  }else{\n    // generic objects\n    r = src.constructor ? new src.constructor() : {};\n  }\n  return mixin(r, src, clone);\n}\n\n// As specified in section 15.10.2.8.\n// When calling this function `ignoreCase` is assumed to be true.\nfunction canonicalize(ch) {\n  var u = String.prototype.toUpperCase.call(ch);\n\n  if (u.length !== 1) {\n    return ch;\n  }\n\n  if (ch.charCodeAt(0) >= 128 && u.charCodeAt(0) < 128) {\n    return ch;\n  }\n\n  return u;\n}\n\nfunction Range(min, max) {\n    if (max - min <= 0) {\n        throw new Error('Range min/max not possible: ' + min + ' ' + max);\n    }\n    this.min = min;\n    this.max = max;\n}\n\nRange.prototype.toString = function() {\n    var minChar = String.fromCharCode(this.min);\n    var maxChar = String.fromCharCode(this.max - 1);\n\n    return '[' + minChar + '-' + maxChar + ']';\n}\n\nRange.prototype.clone = function() {\n    return new Range(this.min, this.max);\n}\n\n/**\n * Return true if the two sets intersect. If they are just edge on, this\n * function returns false.\n *\n *   |----|\n *      |----| => true\n *\n *   |----|\n *        |--| => false\n */\nRange.prototype.hasIntersect = function(other) {\n    return (this.min < other.max && this.max > other.min);\n}\n\nRange.prototype.edgeOnTo = function(other) {\n    return this.min == other.max || this.max == other.min;\n}\n\nRange.prototype.intersect = function(other) {\n    if (!this.hasIntersect(other, true)) {\n        return [];\n    }\n\n    var min = Math.max(this.min, other.min);\n    var max = Math.min(this.max, other.max);\n\n    return [new Range(min, max)];\n}\n\nRange.prototype.subtract = function(other) {\n    if (!this.hasIntersect(other, true)) {\n        // No real intersection -> nothing to subtract.\n        return [new Range(this.min, this.max)];\n    }\n\n    // This range is totally inside the `other` range and therefore removes it.\n    if (this.min >= other.min && this.max <= other.max) {\n        return []\n    }\n    // The other range is inside this range and therefor split this\n    // range up.\n    if (other.min >= this.min && other.max <= this.max) {\n        if (this.min == other.min) {\n            return [new Range(other.max, this.max)];\n        } else if (this.max == other.max) {\n            return [new Range(this.min, other.min)];\n        } else {\n            return [new Range(this.min, other.min), new Range(other.max, this.max)];\n        }\n    }\n\n    if (this.min < other.min) {\n        return [new Range(this.min, other.min)];\n    } else {\n        return [new Range(other.max, this.max)];\n    }\n}\n\nfunction RangeList(negative, initialList) {\n    this.list = initialList || [];\n    this.negative = negative;\n    this.length = this.list.length;\n}\n\nRangeList.prototype.clone = function() {\n    return new RangeList(this.negative, this.list.slice());\n}\n\nRangeList.prototype.toString = function() {\n    return '[' + this.list.map(function(e) { return e.toString() }) + ']';\n}\n\nRangeList.prototype.push = function(range) {\n    this.list.push(range);\n    this.length = this.list.length;\n}\n\n// Merge the ranges if possible and merge overlaying ranges.\nRangeList.prototype.simplify = function() {\n    if (this.list.length == 0) {\n        return;\n    }\n\n    this.list.sort(function(a, b) {\n        return a.min - b.min;\n    });\n\n    var merged = [];\n    var current = this.list[0].clone();\n    for (var i = 1; i < this.list.length; i++) {\n        var range = this.list[i];\n        if (current.hasIntersect(range) || current.edgeOnTo(range)) {\n            // The list is sorted. Therefore current.min <= range.min.\n            if (range.max > current.max) {\n                current.max = range.max;\n            }\n        } else {\n            merged.push(current);\n            current = range.clone()\n        }\n    }\n    merged.push(current);\n    this.list = merged;\n    this.length = this.list.length;\n}\n\n/**\n * Returns from the current RangeList a new RangeList with all the ranges of\n * this range that intersect with any of the otherRangeList ranges.\n */\nRangeList.prototype.intersect = function(otherRangeList, reverse) {\n    reverse = !!reverse;\n    var matches = this.list.filter(function(range) {\n        return otherRangeList.list.some(function(otherRange) {\n            return range.hasIntersect(otherRange);\n        }) !== reverse;\n    });\n    return new RangeList(false, matches);\n};\n\nRangeList.prototype.hasIntersectRange = function(otherRange) {\n    return this.list.some(function(range) {\n        return range.hasIntersect(otherRange);\n    });\n}\n\nRangeList.prototype.hasIntersect = function(otherRangeList, reverse) {\n    return this.intersect(otherRangeList, reverse).length !== 0;\n}\n\n\nexports.isSameArray = function(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n\n    for (var i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nexports.Range = Range;\nexports.RangeList = RangeList;\n\nexports.clone = clone;\nexports.canonicalize = canonicalize;\n\n//@ sourceURL=/lib/utils.js"
));

require.define("/lib/exec.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Whole-script strict mode syntax\n\"use strict\";\n\nvar utils = require('./utils');\nvar parse = require('./parser').parse;\nvar nodeToCharCode = require('./parser').nodeToCharCode;\n\nvar canonicalize = require('./utils').canonicalize;\n\nvar idCounter = 0;\n\nfunction Node(type) {\n    this.id = idCounter++;\n    this.type = type;\n}\n\nNode.EMPTY = 'EMPTY';\nNode.CHAR = 'CHAR';\nNode.CHARSET = 'CHARSET';\nNode.ALTR = 'ALTR';\nNode.JOIN = 'JOIN';\nNode.GROUP_BEGIN = 'GROUP_BEGIN';\nNode.GROUP_END = 'GROUP_END';\nNode.REPEAT = 'REPEAT';\nNode.LOOKAHEAD = 'LOOKAHEAD';\nNode.FUNC = 'FUNC';\nNode.BACKTRACK = 'BACK';    // Used in the tracer only.\nNode.DONE = 'DONE';    // Used in the tracer only.\nNode.FORWARD = 'FORWARD';    // Used in the tracer only.\n\nvar idCounterTrace = 0;\nvar idCounterTraceEntry = 0;\n\nfunction TraceEntry(pos, node, previous) {\n    idCounterTraceEntry++;\n    this.id = idCounterTrace++;\n    this.pos = pos;\n    this.node = node;\n    this.notes = [];\n    this.previous = previous;\n}\n\nTraceEntry.prototype = {\n    addNote: function(pos, node, comment) {\n        this.notes.push(node);\n    }\n}\n\nfunction State(str, inputStr, regExpStr, traces, multiline) {\n    this.str = str;\n    // If ignoreCase is set to true `str` and `inputStr` might differ.\n    this.inputStr = inputStr;\n    this.regExpStr = regExpStr;\n    this.idx = 0;\n    this.matches = [];\n    this.data = {};\n    this.counts = {};\n    this.traces = traces;\n    this.multiline = multiline;\n    this.currentTrace = traces ? traces[traces.length - 1] : null;\n}\n\nState.getCurrentTraceTail = function() {\n    return this.currentTraceTail;\n},\n\nState.setCurrentTraceTail = function(traceTail) {\n    this.currentTraceTail = traceTail;\n},\n\nState.prototype.incr = function() {\n    this.idx += 1;\n};\n\nState.prototype.beginning = function() {\n    // See section 15.10.2.6.\n    if (this.idx === 0) {\n        return true;\n    } else if (this.multiline === false) {\n        return false;\n    } else {\n        return isLineTerminator(this.str.charCodeAt(this.idx - 1));\n    }\n}\n\nState.prototype.finished = function() {\n    // See section 15.10.2.6.\n    if (this.idx == this.str.length) {\n        return true;\n    } else if (this.multiline === false) {\n        return false;\n    } else {\n        return isLineTerminator(this.str.charCodeAt(this.idx));\n    }\n};\n\nState.prototype.getCurrentChar = function() {\n    return this.str[this.idx];\n};\n\nState.prototype.nodeToString = function(node) {\n    var parseEntry = node.parseEntry;\n    if (parseEntry != null && this.regExpStr != null) {\n        return this.regExpStr.substring(parseEntry.from, parseEntry.to);\n    } else {\n        return 'UNSPECIFIED';\n    }\n}\n\nState.prototype.clone = function(node, parentNode) {\n    // Add a new to the list of traces which is used for the execution\n    // of the state.\n    var traces = this.traces;\n    if (traces) {\n        var newTrace = this.currentTrace.slice();\n        newTrace.lastBackIdx = this.currentTrace.lastBackIdx;\n        // newTrace.forkIdx = this.currentTrace.length - 1;\n        traces.push(newTrace);\n    }\n\n    var cloned = new State(\n        this.str,\n        this.inputStr,\n        this.regExpStr,\n        traces,\n        this.multiline\n    );\n    cloned.idx = this.idx;\n    cloned.matches = this.matches.slice(0, this.matches.length);\n    cloned.counts = utils.clone(this.counts);\n    cloned.data = utils.clone(this.data);\n    return cloned;\n};\n\nState.prototype.resetMatch = function(idx) {\n    this.matches[idx] = undefined;\n};\n\nState.prototype.getMatch = function(idx) {\n    return this.matches[idx];\n}\n\nState.prototype.recordMatch = function(idx, str) {\n    this.matches[idx] = str;\n};\n\nState.prototype.set = function(key, value) {\n    this.data[key] = value;\n};\n\nState.prototype.get = function(key) {\n    return this.data[key];\n};\n\nState.prototype.matchString = function(str) {\n    var doMatch = this.str.indexOf(str, this.idx) === this.idx;\n    if (doMatch) {\n        this.idx += str.length;\n    }\n    return doMatch;\n};\n\nState.prototype.incCounts = function(idx) {\n    var oldValue = this.counts[idx] === undefined ? -1 : this.counts[idx];\n    return this.counts[idx] = oldValue + 1;\n};\n\nState.prototype.resetCountBelow = function(idx) {\n    while (idx--) {\n        if (this.counts[idx] !== undefined) {\n            this.counts[idx] = undefined;\n        }\n    }\n}\n\nState.prototype.isWordChar = function(offset) {\n    var idx = this.idx + offset;\n    if (idx === -1 || idx === this.str.length) return false;\n    return (/[a-zA-Z0-9_]/).test(this.str[idx]);\n};\n\n// Things to record a trace on the state.\nState.prototype.recordNode = function(node) {\n    var currentTrace = this.currentTrace;\n    if (currentTrace) {\n        // Recording a new entry makes this trace become the last trace in the\n        // trace list. Last trace = most advanced trace!\n        var traceIdx = this.traces.indexOf(currentTrace);\n        if (traceIdx !== this.traces.length - 1) {\n            this.traces.splice(traceIdx, 1);\n            this.traces.push(currentTrace);\n        }\n        if (!node.dontCountTraceNode)\n            this.traces.data.nodeCounter += 1;\n\n        var previous = currentTrace[currentTrace.length - 1];\n        var newEntry = new TraceEntry(this.idx, node, previous);\n        this.traces.data.traceHash[newEntry.id] = newEntry;\n        this.currentTrace.push(newEntry);\n    }\n};\n\nState.prototype.recordBacktracing = function(node) {\n    if (this.currentTrace) {\n        this.currentTrace.lastBackIdx = this.currentTrace.length - 1;\n        var newNode = new Node(Node.BACKTRACK);\n        newNode.parseEntry = node.parseEntry;\n        this.recordNode(newNode);\n\n        this.traces.data.backrefCounter += 1;\n    }\n};\n\nState.prototype.comment = function(node, comment) {\n    //this.trace.comment(this.idx, node, comment);\n};\n\nState.prototype.failAndUnwind = function() {\n    // Don't do anything to the trace. Maybe remove the trace completly?\n    return false;\n};\n\nState.prototype.fail = function(comment) {\n    var currentTrace = this.currentTrace;\n    if (currentTrace) {\n        currentTrace.isEndTrace = 'failed';\n    }\n    return false;\n};\n\nState.prototype.success = function() {\n    var currentTrace = this.currentTrace;\n    if (currentTrace) {\n        currentTrace.isEndTrace = 'success';\n    }\n};\n\nfunction match(state, node) {\n    function fork(parentNode, childNode, recordFunc, resetMatches) {\n        var forkedState = state.clone(childNode, parentNode);\n\n        if (recordFunc) {\n            recordFunc(forkedState);\n        }\n\n        if (resetMatches) {\n            resetRepeatMaches(node, forkedState);\n        }\n\n        var res = match(forkedState, childNode);\n        return res;\n    }\n\n    function resetRepeatMaches(node, stateToReset) {\n        var parseEntry = node.parseEntry;\n        if (parseEntry && parseEntry.firstMatchIdx != null && parseEntry.firstMatchIdx >= 0) {\n            for (var i = parseEntry.firstMatchIdx; i <= parseEntry.lastMatchIdx; i++) {\n                stateToReset.resetMatch(i);\n            }\n        }\n        // Reset the counters for repeats as well.\n        // Repeat-nodes that are wrapping the current node have a higher ID\n        // number. Therefore it is save to reset all the IDs below the node.\n        stateToReset.resetCountBelow(node.id);\n    }\n\n    var res;\n    while (node) {\n        var nextChar = state.getCurrentChar();\n\n        if (node.type !== Node.REPEAT && node.type !== Node.ALTR) {\n            state.recordNode(node);\n        }\n\n        switch (node.type) {\n            case Node.FUNC:\n                if (!node.func(state)) {\n                    return state.fail();\n                }\n                node = node.next;\n                break;\n\n            case Node.REPEAT:\n                var nodeName = 'node:' + node.id;\n                var lastIdx = state.get(nodeName);\n                if (lastIdx !== undefined && lastIdx === state.idx) {\n                    // Have the case of an empty match. No process is made\n                    // no mather how often this repetition is applied. Therefore\n                    // continue with the next node right away.\n\n                    // If the node can have zero repetitions, then treat the\n                    // repetition as if it has done zero repetitions (it loops,\n                    // therefore take the minimal number possible!).\n                    //\n                    // This also implies, there should be no results for\n                    // containing groups of this node, e.g. /()*/.exec('a')\n                    // should have no match for the first group.\n                    if (node.min === 0) {\n                        resetRepeatMaches(node, state);\n                    }\n\n                    state.set(nodeName, undefined);\n                    return match(state, node.next);\n                } else {\n                    state.set(nodeName, state.idx);\n                }\n\n                // StateCounters start at -1 -> first inc makes the counter be zero.\n                var counter = state.incCounts(node.id);\n                if (counter < node.min) {\n                    resetRepeatMaches(node, state);\n                    state.recordNode(node);\n                    state.comment(node, 'Need to repeat another time');\n                    // Haven't matched the minimum number yet\n                    // -> match one more time.\n                    res = match(state, node.child);\n                } else if (counter === node.max) {\n                    // Have matched the maximum number - match next one.\n                    res = match(state, node.next);\n                } else {\n                    // match \\in {from, to}\n                    if (node.greedy) {\n                        // 15.10.2.5: Greedy - repeat child as many times as possible.\n                        res = fork(node, node.child, function(fState) {\n                            fState.recordNode(node);\n                        }, true);\n                        if (!res) {\n                            state.recordBacktracing(node);\n                            res = match(state, node.next);\n                        }\n                    } else {\n                        // 15.10.2.5: non-greedy - repeat child as less times as possible.\n                        res = fork(node, node.next, function(fState) {\n                            fState.recordNode(node);\n                        });\n                        if (!res) {\n                            state.recordBacktracing(node);\n                            state.recordNode(node);\n                            resetRepeatMaches(node, state);\n                            res = match(state, node.child);\n                        }\n                    }\n                }\n                if (!res) {\n                    return state.fail();\n                }\n                return res;\n\n            case Node.CHARSET:\n                if (state.finished()) {\n                    return state.fail();\n                }\n\n                res = node.children.some(function(f) {\n                    return f(nextChar);\n                });\n\n                if (node.not) {\n                    res = !res;\n                }\n\n                if (res) {\n                    state.incr();\n                    node = node.next;\n                } else {\n                    return state.fail();\n                }\n                break;\n\n\n            case Node.CHAR:\n                if (state.finished()) {\n                    return state.fail();\n                }\n\n                if (node.data === nextChar) {\n                    state.incr();\n                    node = node.next;\n                } else {\n                    return state.fail();\n                }\n                break;\n            case Node.ALTR:\n                for (var i = 0; i < node.children.length; i++) {\n                    res = fork(node, node.children[i], function(fState) {\n                        if (i == 0) {\n                            fState.recordNode(node);\n                        } else {\n                            fState.recordBacktracing(node);\n                        }\n                    });\n                    if (res) {\n                        return res;\n                    }\n                }\n                return state.failAndUnwind();\n\n            case Node.EMPTY:\n            case Node.JOIN:\n                node = node.next;\n                break;\n\n            case Node.GROUP_BEGIN:\n                state.set(node.matchIdx, state.idx);\n\n                node = node.next;\n                break;\n\n            case Node.GROUP_END:\n                // If node.matchIdx >= 0, then it's a group to store the match.\n                // If node.data === -1 -> don't remember the match\n                if (node.matchIdx >= 0) {\n                    var groupStartIdx = state.get(node.matchIdx);\n                    var str = state.inputStr.substring(groupStartIdx, state.idx);\n                    state.recordMatch(node.matchIdx, str);\n                }\n\n                node = node.next;\n                break;\n\n            // E.g. x(?=y) or x(?!y)\n            case Node.LOOKAHEAD:\n                res = fork(node, node.child);\n\n                // If there is a result but the lookahead is negative => FAIL.\n                // If there is NOT a result but the lookahead is positive => FAIL.\n                if (node.not === !!res) {\n                    return state.fail();\n                }\n\n                var parseEntry = node.parseEntry;\n                if (!node.not && parseEntry.firstMatchIdx) {\n                    // In the case of a positive lookahead, copy the matches\n                    // of containing groups over to the current state.\n                    for (var matchIdx = parseEntry.firstMatchIdx;\n                            matchIdx <= parseEntry.lastMatchIdx; matchIdx++)\n                    {\n                        state.recordMatch(matchIdx, res.getMatch(matchIdx));\n                    }\n                }\n\n                node = node.next;\n                break;\n\n            default:\n                throw \"Unkown node type: \" + node.type;\n\n        }\n    }\n\n    if (node) {\n        return state.fail();\n    }\n\n    state.success();\n\n    return state;\n}\n\nfunction retArr(nodes) {\n    return [nodes[0], nodes[nodes.length - 1]];\n}\n\nfunction bText(str) {\n    var nodeA, nodeB;\n\n    if (str === '') {\n        nodeA = new Node(Node.EMPTY);\n        return [nodeA, nodeA];\n    } else if (str.length === 1) {\n        nodeA = new Node(Node.CHAR);\n        nodeA.data = str;\n        return [nodeA, nodeA];\n    }\n\n    var nodes = str.split('').map(function(ch, idx) {\n        var node = new Node(Node.CHAR, idx, idx + 1);\n        node.data = ch;\n        return node;\n    });\n    for (var i = 0; i < nodes.length - 1; i++) {\n        nodes[i].next = nodes[i + 1];\n    }\n\n    return retArr(nodes);\n}\n\n// If group should be a not-remember-group like `(?:x)`, then set\n// `idx=0`.\nfunction bGroup(children, matchIdx, lastMatchIdx) {\n    if (lastMatchIdx === undefined) {\n        lastMatchIdx = matchIdx;\n    }\n\n    var begin = new Node(Node.GROUP_BEGIN);\n    var end = new Node(Node.GROUP_END);\n\n    begin.matchIdx = end.matchIdx = matchIdx;\n    begin.lastMatchIdx = end.lastMatchIdx = lastMatchIdx;\n\n    begin.next = children[0];\n    children[1].next = end;\n\n    begin.dontCountTraceNode = true;\n    end.dontCountTraceNode = true;\n\n    return [begin, end];\n}\n\nfunction bLookahead(children, isNegative) {\n    var node = new Node(Node.LOOKAHEAD);\n    node.child = children[0];\n    node.not = isNegative;\n    return [node, node];\n}\n\nfunction bNotFollowMatch(children) {\n    var node = new Node(Node.NOT_MATCH);\n    node.child = children[0];\n    return [node, node];\n}\n\nfunction bCharacterClass(isNegative, matches) {\n    var nodeA = new Node(Node.CHARSET);\n    nodeA.not = isNegative;\n    nodeA.children = matches;\n\n    return [nodeA, nodeA];\n}\n\nfunction bCharSet(isNot, str) {\n    var nodeA = new Node(Node.CHARSET);\n    nodeA.not = isNot;\n\n    // TODO: Add proper parsing of charSet here.\n    nodeA.children = str.split('').map(function(matchChar) {\n        return function(inputChar) {\n            return inputChar === matchChar;\n        };\n    });\n\n    return [nodeA, nodeA];\n}\n\n// BuildDot is just a shorthand for a charSet excluding all newlines.\nfunction bDot() {\n    return bCharSet(true, '\\n\\r\\u2028\\u2029');\n}\n\nfunction bBoundary(isNegative) {\n    return bFunc(function(state) {\n        // See: 15.10.2.6\n        var a = state.isWordChar(-1);\n        var b = state.isWordChar(0);\n        res = (a === true && b === false) || (a === false && b === true);\n        if (isNegative) {\n            res = !res;\n        }\n        return res;\n    })\n}\n\nfunction bFunc(func) {\n    var node = new Node(Node.FUNC);\n    node.func = func;\n    return [node, node];\n}\n\nfunction buildNodeFromRegStr(str) {\n    return walk(parse(str), false);\n}\n\n\n// TAKEN FROM ESPRIMA! BEGIN >>\n\n// 7.2 White Space\n\nfunction isWhiteSpace(ch) {\n    return (ch === 32) ||  // space\n        (ch === 9) ||      // tab\n        (ch === 0xB) ||\n        (ch === 0xC) ||\n        (ch === 0xA0) ||\n        (ch >= 0x1680 && '\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\uFEFF'.indexOf(String.fromCharCode(ch)) > 0);\n}\n\n// 7.3 Line Terminators\n\nfunction isLineTerminator(ch) {\n    return (ch === 10) || (ch === 13) || (ch === 0x2028) || (ch === 0x2029);\n}\n\n// TAKEN FROM ESPRIMA! << END\n\nfunction buildWhitespaceLineOrTerminator(negative) {\n    // The functions taken from esprima expect to get the charCode of the\n    // character. Therefore wrap the functions, such that the input string\n    // gets converted to an integer before calling the funciton.\n    function strToChar(func) {\n        return function(input) {\n            return func(input.charCodeAt(0));\n        }\n    }\n\n    return bCharacterClass(negative, [\n        strToChar(isWhiteSpace),\n        strToChar(isLineTerminator)\n    ]);\n}\n\nvar escapedChars = {\n    // The build functions are wrapped in a function to create a fresh node\n    // for every escapedChar. Otherwise setting the `next` property on a\n    // node used at multiple places fails.\n    't': function() { return buildNodeFromRegStr('\\\\u0009'); },\n    'n': function() { return buildNodeFromRegStr('\\\\u000A'); },\n    'v': function() { return buildNodeFromRegStr('\\\\u000B'); },\n    'f': function() { return buildNodeFromRegStr('\\\\u000C'); },\n    'r': function() { return buildNodeFromRegStr('\\\\u000D'); },\n    'd': function() { return buildNodeFromRegStr('[0-9]'); },\n    'D': function() { return buildNodeFromRegStr('[^0-9]'); },\n    'w': function() { return buildNodeFromRegStr('[A-Za-z0-9_]'); },\n    'W': function() { return buildNodeFromRegStr('[^A-Za-z0-9_]'); },\n    's': function() { return buildWhitespaceLineOrTerminator(false); },\n    'S': function() { return buildWhitespaceLineOrTerminator(true); },\n    'b': function() { return bBoundary(false); },\n    'B': function() { return bBoundary(true) }\n}\nfunction bEscapedChar(value) {  // 15.10.2.12\n    if (value in escapedChars) {\n        return escapedChars[value]();\n    } else {\n        throw new Error('Unkown escaped char: ' + value);\n    }\n}\n\nfunction bAlt() {\n    var altr = new Node(Node.ALTR);\n    var join = new Node(Node.JOIN);\n    join.dontCountTraceNode = true;\n\n    var children = Array.prototype.slice.call(arguments, 0);\n    altr.children = children.map(function(list) {\n        list[1].next = join;\n        return list[0];\n    });\n\n    return [altr, join];\n}\n\nfunction bJoin() {\n    var args = arguments;\n\n    for (var i = 0; i < args.length - 1; i++) {\n        args[i][1].next = args[i + 1][0];\n    }\n\n    return [args[0][0], args[args.length - 1][1]];\n}\n\n\nfunction bRepeat(greedy, min, max, children) {\n    var node = new Node(Node.REPEAT);\n\n    node.greedy = greedy;\n    node.min = min;\n    node.max = max;\n\n    // Create a loop.\n    node.child = children[0];\n    children[1].next = node;\n\n    return [node, node];\n}\n\nfunction bEmpty() {\n    var node = new Node(Node.EMPTY);\n    return [node, node];\n}\n\nfunction nodeToChar(node, ignoreCase) {\n    var code = nodeToCharCode(node);\n    if (code === null) {\n        return null;\n    }\n\n    var ch = String.fromCharCode(code)\n    if (ignoreCase) {\n        return canonicalize(ch);\n    }\n    return ch;\n}\n\nfunction buildClassRangeIgnoreCase(min, max) {\n    // Computing the canonicalize form of all the characters in `min` to `max`\n    // can result in many disjoint character ranges. Keep track of these\n    // ranges in the `ranges` array.\n\n    var ranges = [];\n    var lastMin = canonicalize(String.fromCharCode(min)).charCodeAt(0);\n    var lastMax = lastMin;\n\n    function saveRange() {\n        ranges.push({\n            min: lastMin,\n            max: lastMax\n        });\n    }\n\n    for (var i = min + 1; i <= max; i++) {\n        var upCharCode = canonicalize(String.fromCharCode(i)).charCodeAt(0);\n\n        // If the canonicalize is not next to the previous max value, then\n        // start a new range.\n        if (upCharCode != lastMax + 1) {\n            saveRange();\n            lastMin = lastMax = upCharCode;\n        } else {\n            lastMax = upCharCode\n        }\n    }\n    saveRange();\n\n\n    return function(input) {\n        // Check if the input character is contained in any of the ranges.\n        var ch = input.charCodeAt(0);\n        return ranges.some(function(range) {\n            return ch >= range.min && ch <= range.max;\n        });\n    }\n}\n\nfunction buildClassMatcher(entry) {\n    switch (entry.type) {\n        case 'character':\n        case 'escape':\n            var ch = nodeToChar(entry, ignoreCase);\n            return function(input) {\n                return ch === input;\n            }\n            break;\n\n        case 'characterClassRange':\n            var min = nodeToCharCode(entry.min);\n            var max = nodeToCharCode(entry.max);\n\n            if (max < min) {\n                // TODO: Better error message.\n                throw new Error('Character not in right order');\n            }\n            if (!ignoreCase) {\n                return function(input) {\n                    var ch = input.charCodeAt(0);\n                    return ch >= min && ch <= max;\n                }\n            } else {\n                return buildClassRangeIgnoreCase(min, max);\n            }\n\n\n        case 'empty':\n            return function(input) { return true; }\n\n        case 'escapeChar':\n            return function(input) {\n                // escapeChar are made up of RegExp again. Do the simpliest way\n                // possible ATM and test the escapeChar against the input string\n                // using the match function itself again ;)\n                // This is not a problem, as escapeChars don't have circular\n                // dependencies.\n                var state = new State(input);\n                var firstNode = bEscapedChar(entry.value)[0];\n                return !!match(state, firstNode);\n            }\n\n        default:\n            throw new Error('Unkown classRange entry type: ' + entry.type);\n    }\n}\n\nvar groupCounter = 1;\nvar ignoreCase = false;\n\nfunction walk(node, inCharacterClass) {\n    var arr;\n    var res;\n    switch (node.type) {\n        case 'disjunction':\n            arr = node.alternatives.map(walk);\n            res = bAlt.apply(null, arr);\n            break;\n\n        case 'alternative':\n            arr = node.terms.map(walk);\n            // Return here directly and don't finish the funciton. This way\n            // the parseEntry of the `alternative` is not set.\n            return  bJoin.apply(null, arr);\n\n        case 'character':\n        case 'escape':\n            res = bText(nodeToChar(node, ignoreCase));\n            break;\n\n        case 'escapeChar':\n            res = bEscapedChar(node.value);\n            break;\n\n        case 'quantifier':\n            res = bRepeat(node.greedy, node.min, node.max, walk(node.child));\n            break;\n\n        case 'group':\n            res = walk(node.disjunction);\n            var isNegativeLookahead = node.behavior === 'negativeLookahead';\n            if (node.behavior === 'lookahead' || isNegativeLookahead) {\n                res = bLookahead(res, isNegativeLookahead);\n            } else {\n                var idx;\n                var endIdx;\n                if (node.behavior === 'ignore') {\n                    idx = -1;\n                } else {\n                    idx = node.matchIdx;\n                    endIdx = node.lastMatchIdx;\n                }\n                res = bGroup(res, idx, endIdx);\n            }\n\n            res[1].parseEntry = node;\n            break;\n\n        case 'characterClass':\n            var matcher = node.classRanges.map(buildClassMatcher);\n            res = bCharacterClass(node.negative, matcher);\n            break;\n\n        case 'empty':\n            res = bEmpty();\n            break;\n\n        case 'dot':\n            res = bDot();\n            break;\n\n        case 'assertion':\n            if (node.sub === 'start') {\n                res = bFunc(function(state) {\n                    return state.beginning();\n                });\n            } else {\n                res = bFunc(function(state) {\n                    return state.finished();\n                });\n            }\n            break;\n\n        case 'ref':\n            res = bFunc(function(state) {\n                var refMatch = state.matches[node.ref];\n                if (refMatch === undefined) {\n                    return true;\n                }\n                state.comment(null, 'referenced value: ' + refMatch);\n                return state.matchString(refMatch);\n            });\n            break;\n\n        default:\n            throw new Error('Unsupported node type: ' + node.type);\n    }\n    res[0].parseEntry = node;\n    return res;\n}\n\nfunction buildFakeParseEntry(from, to, bit) {\n    return {\n        from: from,\n        to: to,\n        bit: bit,\n        booting: true\n    };\n}\n\nfunction getStartNodeFromPattern(regExpStr, ignoreCaseArg) {\n    idCounter = 0;\n    groupCounter = 1;\n    ignoreCase = ignoreCaseArg;\n\n    var parseTree = parse(regExpStr);\n    if (parseTree.error) {\n        throw parseTree.error;\n    }\n\n    var tree = walk(parseTree, false);\n\n    // Create a new group with index 0 that records the overall match.\n    var bootGroup = bGroup(tree, 0, parseTree.lastMatchIdx);\n    var bootGroupParseEntry = buildFakeParseEntry(-1, Number.MAX_VALUE, '()');\n    bootGroup[0].dontCountTraceNode = true;\n    bootGroup[1].dontCountTraceNode = true;\n    bootGroup[0].parseEntry = bootGroup[1].parseEntry = bootGroupParseEntry;\n\n    var startNode = bootGroup[0];\n\n    startNode.regExpStr = regExpStr;\n    startNode.lastMatchIdx = parseTree.lastMatchIdx;\n    startNode.parseTree = parseTree;\n\n    return startNode;\n}\n\nfunction exec(matchStr, startNode, lastIndex, multiline, ignoreCase) {\n    idCounterTrace = 0;\n    idCounterTraceEntry = 0;\n    var regExpStr = startNode.regExpStr;\n    var lastMatchIdx = startNode.lastMatchIdx;\n\n\n    var inputStr = matchStr;\n    if (ignoreCase === true) {\n        if (/^[\\0-\\177]*$/.test(matchStr)) {\n            // Fast path if only ASCII characters are used.\n            // Call str.toUpperCase() directly.\n            matchStr = matchStr.toUpperCase();\n        } else {\n            // Slow path.\n            // Call the `canonicalize` for every character.\n            matchStr = matchStr.split('').map(canonicalize).join('');\n        }\n    }\n\n    var recordTrace = matchStr.length < 100;\n\n    var trace;\n    if (recordTrace) {\n        var firstTrace = [];\n        firstTrace.lastBackIdx = -1;\n        var traces = [firstTrace];\n        var traceHash = {};\n        traces.data = {\n            traceHash: traceHash,\n            nodeCounter: 0,\n            backrefCounter: 0\n        };\n\n        var traceForwarding = [];\n    } else {\n        trace = null;\n    }\n\n\n    var endState;\n    var state;\n    while (lastIndex < matchStr.length) {\n        state = new State(matchStr, inputStr, regExpStr, traces, multiline);\n        state.idx = lastIndex;\n        state.matches = new Array(lastMatchIdx + 1);\n        endState = match(state, startNode);\n\n        lastIndex += 1;\n\n        // If there is an end state, then there is a match and the loop can\n        // be termianted.\n        if (endState) break;\n\n        if (recordTrace) {\n            // Create the next line in the tracer with the right number of FORWARD\n            // nodes.\n            var forwardNode = new Node(Node.FORWARD);\n            var traceNode = new TraceEntry(lastIndex, forwardNode, null);\n            traceHash[traceNode.id] = traceNode;\n            traceForwarding.push(traceNode);\n            var initialTrace = traceForwarding.slice();\n            initialTrace.lastBackIdx = lastIndex - 2;\n            traces.push(initialTrace);\n        }\n    }\n\n    // trace.entryCount = idCounterTraceEntry;\n    // endState.trace = trace;\n\n    if (!endState) {\n        endState = {};\n    } else {\n        var matches = endState.matches;\n        matches.index = endState.idx - matches[0].length;\n        matches.input = matchStr;\n\n        // This is necessary as otherwise the length of the matches might fit\n        // but calling Object.keys don't return the undefineds.\n        for (var i = 0; i < lastMatchIdx + 1; i++) {\n            if (matches[i] === undefined) {\n                matches[i] = undefined;\n            }\n        }\n    }\n\n    endState.traces = traces;\n    endState.parseTree = startNode.parseTree;\n    return endState;\n}\n\nexports.getStartNodeFromPattern = getStartNodeFromPattern;\nexports.exec = exec;\n\n//@ sourceURL=/lib/exec.js"
));

require.define("/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Whole-script strict mode syntax\n\"use strict\";\n\nvar JIT = require('./lib/jit');\nvar getStartNodeFromPattern = require('./lib/exec').getStartNodeFromPattern;\nvar exec = require('./lib/exec').exec;\nvar canonicalize = require('./lib/utils').canonicalize;\n\nvar BuildInRegExp = RegExp;\n\n// See Section 9.3. Only losely following the spec here.\nfunction ToNumber(value) {\n    if (value === undefined) {\n        return NaN;\n    } else if (value === null) {\n        return +0;\n    } else if (value === true) {\n        return 1;\n    } else if (value === false) {\n        return +0;\n    } else if (typeof value === 'number') {\n        return value;\n    } else if (typeof value === 'string') {\n        // This is not really what the spec says.\n        return parseFloat(value);\n    } else {\n        // This is not really what the spec says.\n        var r = parseFloat(value.valueOf());\n        if (isNaN(r)) {\n            return parseFloat(ToString(value));\n        }\n        return r;\n    }\n}\n\nfunction sign(x) {\n    return x >= 0 ? 1 : -1;\n}\n\n// See Section 9.4. Only losely following the spec here.\nfunction ToInteger(value) {\n    var number = ToNumber(value);\n\n    if (isNaN(number)) {\n        return +0;\n    } else if (number === 0 || !isFinite(number)) {\n        return number;\n    } else {\n        return sign(number) * Math.floor(Math.abs(number));\n    }\n}\n\n// See Section 9.8. Only losely following the spec here.\nfunction ToString(input) {\n    var t = input;\n\n    if (input === undefined) {\n        return 'undefined';\n    } else if (input === null) {\n        return 'null';\n    } else if (input === false) {\n        return 'false';\n    } else if (input === true) {\n        return 'true';\n    } else if (typeof input === 'number') {\n        return input + '';\n    } else if (typeof input === 'string') {\n        return input;\n    }\n\n    // If there is a toString property that is callback.\n    if (input.toString && input.toString.call) {\n        input = input.toString();\n    } else if (t.valueOf) {\n        input = t.valueOf();\n    }\n    return ToString(input);\n}\n\nvar __DIRECT_RETURN__ = {};\n\nfunction RegExpJS(pattern, flags) {\n    // Hack to make `RegExpJSReturn.prototype = new RegExpJS(RegExpJSReturn);`\n    // work :)\n    if (pattern === __DIRECT_RETURN__) {\n        return this;\n    }\n\n    // Calling RegExp('a') is valid and should return a new object.\n    if (this === undefined || this.__proto__ !== RegExpJS.prototype) {\n        return new RegExpJS(pattern, flags);\n    }\n\n    if (pattern === null) {\n        pattern = 'null';\n    } else if (!pattern) {\n        pattern = '(?:)';\n    }\n\n    // Don't recreate a RegExpJS object if the passed in pattern is already\n    // an RegExpJS object.\n    if (pattern instanceof RegExpJS) {\n        if (flags === undefined) {\n            return pattern;\n        } else {\n            throw new TypeError('Cannot supply flags when constructing one RegExp from another');\n        }\n    }\n\n    // if (flags !== undefined) {\n    //     throw new Error('Flags are not supported yet');\n    // }\n\n    if (pattern instanceof BuildInRegExp) {\n        var str = ToString(pattern);\n        pattern = str.substring(1, str.lastIndexOf('/'));\n        flags = str.substring(str.lastIndexOf('/') + 1);\n    } else {\n        pattern = ToString(pattern);\n    }\n\n    // TOOD: What should happen if flags are passed via the pattern AND\n    // as second arguemtn?\n\n    function invalidFlags() {\n        // flag is invalid if it is is null\n        if (flags === null) return true;\n\n        flags = ToString(flags);\n\n        // flags is invalid if it is made up of any other character\n        // than g, i, m or consists any of these letters more than once.\n        return !/^(?:g|i|m)*$/.test(flags) ||\n          /(i[^i]*){2,}/.test(flags) ||\n          /(g[^g]*){2,}/.test(flags) ||\n          /(m[^m]*){2,}/.test(flags);\n    }\n\n    // Check if the passed in flags are valid.\n    if (flags !== undefined && invalidFlags()) {\n        throw new SyntaxError('Invalid flags supplied to RegExp constructor ' + flags);\n    } else {\n        flags = flags || '';\n    }\n\n    var self = this;\n    this.constructor = BuildInRegExp;\n\n    function freezeIt(prop, propValue) {\n        // The `source` property\n        Object.defineProperty(self, prop, {\n          writable: false,\n          enumerable: false,\n          configurable: false,\n          value: propValue\n        });\n    }\n\n    freezeIt('source', pattern);\n    freezeIt('global', flags.indexOf('g') !== -1);\n    freezeIt('ignoreCase', flags.indexOf('i') !== -1);\n    freezeIt('multiline', flags.indexOf('m') !== -1);\n\n    Object.defineProperty(this, 'lastIndex', {\n      writable: true,\n      enumerable: false,\n      configurable: false,\n      value: 0\n    });\n\n    this.$startNode = getStartNodeFromPattern(pattern, this.ignoreCase);\n\n    // Don't allow to overwrite the toString property on the object.\n    Object.defineProperty(this, 'toString', {\n      writable: false,\n      enumerable: false,\n      configurable: false,\n      value: function() { return '[object RegExp]'; }\n    });\n}\n\nRegExpJS.prototype = new RegExp();\n\nRegExpJS.prototype.execDebug = function RegExpJSExec(str) {\n    // See: 15.10.6.2\n    var i = this.lastIndex;\n    if (this.global === false) {\n        i = 0;\n    } else {\n        i = ToInteger(i);\n    }\n\n    str = ToString(str);\n\n    if (i < 0 || i > str.length) {\n        this.lastIndex = 0;\n        // This makes the caller RegExpJS.prototype.exec\n        // return `null`.\n        return { matches: null };\n    }\n\n    var res = exec(str, this.$startNode, i, this.multiline, this.ignoreCase);\n\n    if (res.matches && this.global === true) {\n        this.lastIndex = res.idx;\n    }\n    return res;\n};\n\nRegExpJS.prototype.exec = function RegExpJSExec(str) {\n    // console.log('RegExpJS.prototype.exec', str)\n    var res = this.execDebug(str);\n\n    if (res.matches) {\n        return res.matches;\n    } else {\n        return null;\n    }\n};\n\nRegExpJS.prototype.test = function RegExpJSTest(str) {\n    return this.exec(str) !== null;\n};\n\nRegExpJS.prototype.exec.prototype = undefined;\nRegExpJS.prototype.test.prototype = undefined;\n\nif (typeof window !== 'undefined') {\n    window.RegExpJS = RegExpJS;\n    if (!window.require) {\n        window.require = require;\n    }\n}\n\nvar proto = RegExpJS.prototype;\nObject.defineProperty(RegExpJS, 'prototype', {\n  writable: false,\n  enumerable: false,\n  configurable: false,\n  value: proto\n});\n\nexports.RegExpJS = RegExpJS;\n//@ sourceURL=/index.js"
));
require("/index.js");
})();
